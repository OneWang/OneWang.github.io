---
layout: post
title: 读书笔记
date: 2017-08-08
---

### 1、OC语言的起源：
消息和函数的区别：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器来决定；如果代码中调用的函数是多态，那么在运行时就要按照“虚方法表”来查出到底应该执行那个函数实现；而采用消息结构的语言，不论是否多态，总是在运行时才会去查找索要执行的方法；实际上，编译器甚至不关心接受消息的对象时何种类型；接收消息的对象问题也要在运行时处理；其过程叫做“动态绑定”

要点：
* OC为C语言添加了面向对象的特性，是其超集。OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型；接收一条消息之后，究竟应执行何种代码，由运行环境而非编译器来决定；

### 2.在类的头文件中尽量少引入其它头文件
要点：
* 除非确有必要，否则不要引入头文件；一般来说，应在某个类的头文件中使用向前声明来提及别的类；并在实现文件中引入那些类的头文件；这样做可以尽量降低类之间的耦合；
* 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明一直“分类”中；如果不行的话，就把协议单独放在一个头文件中，然后将其引入；

### 3.多用字面量语法，少用与之等价的方法
字面量语法有个小限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架才行；
要点:
* 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要；
* 应该通过取下表操作来访问数组下表或字典中的键所对应的元素；
* 用字面量语法创建数组或者字典时，若值中有nil，则会抛出异常，因此，务必确保值里不含nil;

### 4.多用类型常量，少用#define预处理指令
常用的命名法是：若常量局限于某“编译单元（也就是“实现文件”之内）”，则在前面加字母k，若常量在类之外可见，则通常以类名为前缀；在声明变量时不加static，则编译器会为它创建一个额“外部符号”，此时若是另一个编译单元中也声明了同名变量，那么编译器就抛出一条错误信息；既声明为static，又声明为const，那么编译器根本不会创建符号；
要点：
* 不要用预处理指令定义常量；这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作；即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中常量值的不一致；
* 在实现文件中是static const来定义“只在编译单元内可见的常量”。由于此类常量不在全局符号表中，所以无须为其名称加前缀；
* 在头文件中是extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀；

### 5.用枚举表示状态、选项、状态码
要点：
* 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字；
* 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项定义为2的幂，以便通过按位或操作将其组合起来；
* 用NS_ENUM和NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型；
* 在处理枚举类型的switch语句中不要实现default分支，这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有的枚举；

第二章：对象、消息、运行时

### 6.理解“属性”这一概念

@synthesize 编译器自动编写访问这些属性所需的方法，此过程叫做“自动合成”；
@dynamic 告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法；

属性可以拥有的特质：
原子性：默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质，但是仍然可以在属性特质中写明这一点，编译器不会报错，若是自己定义的存取方法，那么就应该遵从与属性特质相符的原子性；（在iOS中使用同步锁的开销较大，这会带来性能问题，一般情况下并不要求属性必须是“原子性”，因此这并不能保证“线程安全”，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行）
读/写权限：readwrite/readonly
内存管理语义:
assign ：设置方法只会执行针对“纯量类型”的简单赋值操作
strong ：此特质表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会被先保留新值，并释放旧值，然后再将新值设置上去；
week ：此特质表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到摧毁时，属性值也会被清空；
Unsafe_unretained ：此特质的语义和assign相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空，这一点与weak有区别；
copy ：此特质所表达的所属关系与strong类似，然而设置方法并不保留新值，而是将其“拷贝”。

方法名：可以为属性设置自定义的存取方法名

要点：
* 可以用@property语法来定义对象中所封装的数据
* 通过“特质”来指定存储数据所需的正确语义
* 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义
* 开发iOS程序时应该使用nonatomic属性，因为atomic属性会严重影响性能

### 7.在对象内部尽量直接访问实例变量

直接访问和属性访问的区别：
1. 由于不经过OC的“方法派发”步骤，所以直接访问实例变量的速度当然比较快；在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存；
2. 直接访问实例变量时，不会调用“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。如：如果在ARC下直接访问一个声明为copy的属性，那么并不会拷贝该属性，只会保留新值并释放旧值；
3. 直接访问实例变量，就不会触发“键值观察”通知（KVO）；
4. 通过属性来访问有助于排查与之相关的错误，因为给“获取/设置方法”中新增断点监控，监控该属性的调用者及其访问时机；

要点：
* 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写；
* 在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据l;
* 有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据；

### 8.理解“对象等同性”这一概念

==操作符比较的是两个指针本身，而不是其所指的对象；
isEqual：来判断两个对象的等同性；

若两个对象相等，则其哈希码也相等，但是两个哈希码相同的对象却未必相等

要点：
* 若想检测对象的等同性，请提供“isEqual：”和hash方法
* 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同
* 不要盲目地逐个检测每条属性，而是应该依照具体需求来指定检测方案
* 编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法

### 9.以“类族模式”隐藏实现细节

系统框架中有很多类族。大部分集合类都是类族；在使用NSArray的alloc方法来获取实例时，该方法首先会分配一个属于某类的实例，此实例充当“占位数组”。该数组稍后会转为另一个类的实例，而那个类则是NSArray的实体子类；

想cocoa中NSArray这样的类族来书，还是有办法新增子类的，但是需要遵守以下几条规则：
1.子类应该继承自类族中的抽象基类；
若要编写NSArray类族的子类，则需令其继承自不可变数组的基类或可变数组的基类；
2.子类应该定义自己的数据存储方式；
开发者编写NSArray子类时，经常在这个问题上受阻；子类必须用一个实例变量来存放数组中的对象；这似乎和大家预想的不一样，我们以为NSArray自己肯定会保存那些对象，所以在子类中就无需再存一份了，但是大家要记住，NSArrzy本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需要具备的一些接口；对于这个自定义的数组子类来说，可以用NSArray来保存其实例；
3.子类应当覆写超类文档中指明需要覆写的方法；

要点：
* 类族模式可以把实现细节隐藏在一套简单的公共接口后面；
* 系统框架中经常使用类族；
* 从系统的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读；

### 10.在既有类中使用关联对象存放自定义数据

要点：
* 可以通过“关联对象”机制来把两个对象关联起来；
* 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”；
* 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug；

### 11.理解objc_msgSend的作用
objc_msgSend通过接收者所属的类搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就调至其实现代码；若是找不到就沿着继承体系继续向上查找，等找到合适的方法之后再跳转；再找到匹配的方法之后objc_msgSend会将匹配结果缓存在“快速映射表”里面，每个类都有这样的一块缓存，若是稍后还向该类发送与选择子相同的消息，那么执行起来就很快了；当然这种“快速执行路径”还是不如“静态绑定的函数调用操作”那么迅速，不过只要把选择子缓存起来，也就不会慢很多了，实际上消息派发并非应用程序的瓶颈所在；如果最终还是没有找到相符的方法，那就执行“消息转发”操作；

其他“边界情况”则需要交由OC运行环境中的另一些函数来处理：
objc_msgSend_stret 如果待发送的消息返回结构体，那么可交由此函数处理；只有当CPU的寄存器能够容纳的下消息返回类型时，这个函数才能处理此消息；若是返回值无法容纳与CPU寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发；此时哪个函数会通过分配在栈上的某个变量来处理消息所返回的结构体；

objc_msgSend_fpret 如果消息返回的是浮点数，那么可交由此函数处理，在某些结构的CPU中调用函数时，需要对“浮点数寄存器”做特殊处理，也就是说通常所用的objc_msgSend在这种情况下并不合适，这个函数时为了处理x86等架构CPU中某些令人稍觉惊讶的奇怪情况；

objc_msgSendSuper 如果要给超类发消息，那么就交由此函数处理；也有另外两个与objc_msgSend_stret 和 objc_msgSend_fpret 等效的函数，用于处理发给super的相应消息；

每个类中都有一张表格，其中的指针都会指向这种函数，而选择子的名称就是查表是所用的key；objc_msgSend等函数正是通过这张表格来寻找应该执行的方法并跳至其实现的；请注意：原型的样子和objc_msgSend函数很像，这不是巧合，而是为了利用“尾调用优化”技术，令“跳至方法实现”这一操作变得更简单些；
如果某函数的最后一项操作是调用另外一个函数，那么就可以运用“尾调用优化”技术；编译器会生成跳转至另一函数所需的指令码，而且不会向调用堆栈中推入新的“栈帧”；只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另做他用时，才能执行“尾调用优化”；这项优化对objc_msgSend非常关键，不这么做的话，那么每次调用OC方法之前，都需要调用objc_msgSend函数准备“帧栈”；若是不优化，还会过早的发生“栈溢出”现象；

要点：
* 消息由接收者、选择子及参数构成，给某个对象发送消息也就相当于该对象上调用方法；
* 发给某个对象的全部消息都要由“动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码；

### 12.理解消息转发机制
动态方法解析
备援接收者
完整的消息转发
消息转发全流程

要点：
* 若对象无法响应某个选择子，则进入消息转发流程；
* 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中；
* 对象可以把其无法解读的某些选择子转交给其他对象来处理
* 经过上述两部之后，如果还是没办法处理选择子，那就启动完整的消息转发机制；

